# 第 22.12 节 安装 code-server 和 clangd

> **警告**
>
> 本教程仍然需要进一步测试，请慎重参考。

## 常见问题

### 为什么要有这篇教程？

- 有了 code-server 就意味着不用安装桌面环境即可获得运行在原生 FreeBSD 环境上的集成开发环境
- 利用熟悉的 vscode 界面和强大的 clangd 支援 FreeBSD 内核的开发
- 这样可以大大降低投入 FreeBSD 代码贡献以及二次开发所需的学习成本

### 为什么要用 Arch Linux 兼容层？

- 因为现在 FreeBSD 版的 code-server 被上游搞坏了几乎没法用
- 纵观历史版本也只有一个 revision 是好的
- 所以用 Linux 兼容层来运行是目前最节省时间节省生命的方案
- 并且 code-server 自从基于 node18 以后就对 glibc 的最低版本做出了更高的要求
- 源里那个 CentOS 运行时就运行不起它来了

### 兼容层？那还能用来搞 FreeBSD 的开发吗？

- 当然可以
- 虽然为了运行 code-server 我们用到了 Linux 兼容层
- 但是 clangd 还有任何其他开发工具将全部由 FreeBSD 提供
- 这是由于我们将要诱导 clangd 插件去启动 FreeBSD 上的 clangd
- 与此同时我们还将诱导 Integrated Terminal 去启动 FreeBSD 上的 shell

### 你说的「诱导」到底是什么意思？

- 如你所见，现在这个 code-server 处于综合因素的考量现在是运行在 FreeBSD 的 Linux 二进制兼容模式下
- 但首先我们清楚，这个是 Linux 二进制兼容，不是 Linux 虚拟机

- 既然是 Linux 二进制兼容，那么尝试去运行 Linux 程序的主体一定还是 FreeBSD 本身，并没有额外多出来一个 Linux guest
- 既然主体还是 FreeBSD ，那么一定会涉及到运行 Linux 程序和 FreeBSD 程序混合运行的问题
- 既然涉及到运行 Linux 程序和 FreeBSD 程序混合运行的问题，那么一定也会涉及到用 Linux 还是 FreeBSD 的动态链接库 (DLL) 的问题

- 对于一个已经编译好的二进制程序来说，它要用到什么 DLL 是写死了的
- 假设一个 Linux 二进制程序依赖 `/lib/glibc.so` ，那么它一定会到 `/lib/glibc.so` 去寻找这个文件，绝对不会看向其他地方
- 但是我们都知道在 FreeBSD 上， Linux 的运行时环境在 `/compat/linux` 下面

- 这时候要么给这个 Linux 二进制程序打补丁，把依赖 `/lib/glibc.so` 改成依赖 `/compat/linux/lib/glibc.so`
- 想想也都知道这样做难度有多么大，而且总归会有漏网之鱼吧？

- 那就试试第二个方法：在「非常底层的某个地方」实现对路径的劫持
- 当一个 Linux 二进制程序尝试去 open 某个文件，假使说就是这个程序尝试去调用 `/lib/glibc.so` 这个动态链接库的时候
- 内核首先会给 `/lib/glibc.so` 这个路径前面加上 `/compat/linux` 变成 `/compat/linux/lib/glibc.so`

- 但如果尝试去 open 的不是 `/compat/linux` 下面有的文件，而是 `/compat/linux` 外面的某个文件呢？
- 这个时候会自动 fallback 到程序传入的原始路径，尝试再 open 一次，并祈祷这次能 open 成功
- 如果这次还是失败，那就真的失败了，无药可救

- 我们回到 code-server 这里
- code-server 是一个 Linux 程序，所以当我们尝试打开一个文件或者目录，它一定是先去 `/compat/linux` 下面去找
- 比方说我们要打开 `/usr/src` 这个目录，一般来说你是想要看 FreeBSD 的源码树，对吧？
- 可如果 `/compat/linux/usr/src` 这个目录存在，那么被打开的实际上就会是 `/compat/linux/usr/src` 而不是你想要的 `/usr/src`
- 这时候我们就需要把 `/compat/linux/usr/src` 这个目录删除掉，确保内核帮你 fallback 到真正的 `/usr/src` 上面去
- 「诱导」这个名字就是这么来的

### 还有什么需要补充的内容？

- 如何在服务器上通过 HTTPS 来提供 code-server 服务
- 探讨 Linux 兼容层与 Linux Jail 究竟有何区别

### 有什么需要注意的？

- 所有操作都使用 root 用户进行
- 请勿跳步

### 你这是在鼓励用户当 root 敢死队？

- 。。。

## 服务器启用 Linux 二进制兼容，并部署 archlinux-bootstrap 镜像

```shell
service linux enable
service linux start
fetch -o /tmp https://mirrors.cernet.edu.cn/archlinux/iso/latest/archlinux-bootstrap-x86_64.tar.gz
tar -C /tmp -xpf /tmp/archlinux-bootstrap-x86_64.tar.gz || true
cp -Rf /tmp/root.x86_64/* /compat/linux
```

## 服务器配置 pacman 源，并添加 archlinuxcn 仓库

```shell
cat >/compat/linux/etc/pacman.conf <<EOF
[options]
Architecture = auto
ParallelDownloads = 5

[core]
Server = https://mirrors.cernet.edu.cn/archlinux/\$repo/os/\$arch
SigLevel = Required DatabaseOptional

[extra]
Server = https://mirrors.cernet.edu.cn/archlinux/\$repo/os/\$arch
SigLevel = Required DatabaseOptional

[archlinuxcn]
Server = https://mirrors.cernet.edu.cn/archlinuxcn/\$arch
SigLevel = Required DatabaseOptional
EOF
```

## 服务器初始化 Arch Linux 运行时环境

```shell
chroot /compat/linux pacman-key --init
chroot /compat/linux pacman-key --populate
```

## 服务器更新 Arch Linux 运行时环境，并安装 code-server

```shell
cp /etc/resolv.conf /compat/linux/etc
chroot /compat/linux pacman -Syu --noconfirm
chroot /compat/linux pacman -S --noconfirm archlinuxcn-keyring
chroot /compat/linux pacman -S --noconfirm code-server
```

## 服务器删除 Arch Linux 运行时环境中的无用目录

```shell
rm -Rf /compat/linux/home
rm -Rf /compat/linux/root
rm -Rf /compat/linux/usr/local
rm -Rf /compat/linux/usr/src
```

## 服务器安装相关开发工具及 code-server 插件，并切换 shell 至 bash

```shell
pkg-static upgrade -y git bash vim tmux htop llvm bear
code-server --install-extension llvm-vs-code-extensions.vscode-clangd
chsh -s /usr/local/bin/bash
```

### 安装 code-server 关 bash 什么事？

- 安装 bash 的一个原因在于我们需要确保能够成功诱导 code-server 启动安装在 FreeBSD 上的 shell
- 安装 bash 的另一个原因在于 Integrated Terminal 的 Shell Integration 功能只支持 bash, zsh 和 pwsh

### 为什么要诱导 code-server 去启动安装在 FreeBSD 上的 shell ？

- 你不想当你打开 shell 的时候因为 `/compat/linux/etc/passwd` 里面没有你的 UID 而报错吧
- 你也不想你以为你编译了个 FreeBSD 二进制，实际上你编译了个 Linux 二进制吧

### 好吧，那你凭什么断言只要安装了 bash 就可以诱导成功？

- 诱导成功的充要条件在于 `/compat/linux` 下面找不到对应的目录结构，而这个目录结构在 FreeBSD 上是存在的
- FreeBSD 上的 bash 是装在 `/usr/local` 下面的，而这个目录结构在上一步被我们从 `/compat/linux` 里面删了
- 同理，删除 `/compat/linux` 下面的 `/home` 和 `/root` 就可以诱导到 FreeBSD 上的家目录

## 服务器通过 daemon 命令启动 code-server

```shell
ln -sf /compat/linux/lib/code-server/bin/code-server /usr/local/bin
daemon -p /root/.code-server.pid -f code-server --auth=none
```

## 客户端通过 SSH 建立隧道并通过浏览器连接到 code-server 服务器

```shell
ssh -L 8080:127.0.0.1:8080 -N root@server
```

在浏览器中访问 [http://127.0.0.1:8080](http://127.0.0.1:8080)

## 浏览器中添加以下 code-server 设置

```json
{
  "clangd.path": "/usr/local/bin/clangd",
  "terminal.integrated.profiles.linux": {
    "bash": {
      "path": "/usr/local/bin/bash"
    }
  }
}
```

## （示例）浏览器中用 code-server 打开 FreeBSD 的源码树

```shell
code-server /usr/src
```

## （示例）浏览器中编译最小化内核并生成 `compile_commands.json` 文件

```shell
bear --append -- make KERNCONF=MINIMAL buildkernel
```

等待编译完成并生成 `compile_commands.json` 文件，然后你就可以开始阅读内核关键部分的源码了。

## 自动化安装脚本

为了便于读者快速获得开发环境，我们将安装 code-server 的步骤整理成一个脚本：

```shell
#!/bin/sh

set -e

ARCHLINUX_MIRROR="https://mirrors.cernet.edu.cn/archlinux"
ARCHLINUXCN_MIRROR="https://mirrors.cernet.edu.cn/archlinuxcn"
FREEBSD_PKG_MIRROR="https://mirrors.cernet.edu.cn/FreeBSD-pkg"

umount -Af

rm -Rf /compat/linux
rm -Rf /tmp/archlinux-bootstrap-x86_64.tar.gz
rm -Rf /tmp/root.x86_64

service linux enable
service linux start

fetch -o /tmp "${ARCHLINUX_MIRROR}/iso/latest/archlinux-bootstrap-x86_64.tar.gz"
tar -C /tmp -xpf /tmp/archlinux-bootstrap-x86_64.tar.gz || true
cp -Rf /tmp/root.x86_64/* /compat/linux

rm -Rf /compat/linux/home
rm -Rf /compat/linux/root
rm -Rf /compat/linux/usr/local
rm -Rf /compat/linux/usr/src
rm -Rf /tmp/archlinux-bootstrap-x86_64.tar.gz
rm -Rf /tmp/root.x86_64

mkdir -p /usr/local/etc/pkg/repos
cat >/usr/local/etc/pkg/repos/FreeBSD.conf <<EOF
FreeBSD: { url: "${FREEBSD_PKG_MIRROR}/\${ABI}/latest" }
EOF

cat >/compat/linux/etc/pacman.conf <<EOF
[options]
Architecture = auto
ParallelDownloads = 5

[core]
Server = ${ARCHLINUX_MIRROR}/\$repo/os/\$arch
SigLevel = Required DatabaseOptional

[extra]
Server = ${ARCHLINUX_MIRROR}/\$repo/os/\$arch
SigLevel = Required DatabaseOptional

[archlinuxcn]
Server = ${ARCHLINUXCN_MIRROR}/\$arch
SigLevel = Required DatabaseOptional
EOF

chroot /compat/linux pacman-key --init
chroot /compat/linux pacman-key --populate

cp /etc/resolv.conf /compat/linux/etc

chroot /compat/linux pacman -Syu --noconfirm
chroot /compat/linux pacman -S --noconfirm archlinuxcn-keyring
chroot /compat/linux pacman -S --noconfirm code-server

ln -sf /compat/linux/lib/code-server/bin/code-server /usr/local/bin

pkg-static upgrade -y git bash vim tmux htop llvm bear
code-server --install-extension llvm-vs-code-extensions.vscode-clangd

chsh -s /usr/local/bin/bash
```

欢迎测试与反馈。
